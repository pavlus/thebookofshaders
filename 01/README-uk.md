# Початок подорожі
## Що таке "фрагментний шейдер"?

В попередньому розділі ми описали шейдери як відповідник друкарському пресу Гутенберга для графіки. Чому? А важливіше -- що ж таке "шейдер"?

![From Letter-by-Letter, Right: William Blades (1891). To Page-by-page, Left: Rolt-Wheeler (1920).](print.png)

Якщо ви вже маєте досвід малювання за допомогою комп'ютеру, ви помітили, що малюєте коло, квадрат, лінію, кілька трикутників і т.д., доки не досягнете бажаного результату. Цей процес дуже схожий на написання листа чи книги від руки -- набір послідовних інструкцій. 

Шейдери також являють собою набори інструкцій, але інструкції виконуються всі й одразу для кожного пікселю на екрані. Це значить, що написаний вами код поводить себе залежно від позиції на екрані. Подібно друкарському станку, ваша програма працювати як функція, що приймає координати і повертає колір, а скомпільованою працюватиме надзвичайно швидко. 

![Chinese movable type](typepress.jpg)

## Що робить шейдери швидкими?

Щоб відповісти на це питання, я покажу вам чудеса *паралельних обчислень*.

Уявіть собі, що центральний процесор вашого комп'ютеру -- величезна магістральна труба, і кожна задача це щось, що через неї проходить. Деякі задачі більші за інші, тому потребують більше часу та енергії. Ми кажемо, що вони "потребують більше обчислювальної потужності". Зважаючи на архітектуру комп'ютерів, задачі змушені виконуватися послідовно, кожна задача виконується окремо. Сучасні комп'ютери зазвичай мають групи по чотири процесори, що працюють як вищезгадані труби, виконуючи задачі одна за одною аби забезпечити стабільну роботу системи. Кожна така "труба" також відома як *потік*. 


![Центральний процесор](00.jpeg)

Відеоігри та інші графічні застосунки потребують набагато більше обчислювальної потужності ніж інші програми. Через їх графічну природу, їм потрібно виконувати величезну кількість операцій попіксельно. Кожен окремий піксель на екрані має бути розрахований, а 3D ігри потребують також розрахунку геометрії і перспективи. 

Повернімося до нашої метафори про туби і задачі. Кожен піксель на екрані відповідає простій маленькій задачі. Розрахувати кожен піксель окремо на центральному процесорі не є проблемою, але (і ось у чому полягає проблема) ця маленька задача має бути виконана для кожного пікселю на екрані! Значить для старенького екрану 800х600 кожного кадру треба обчислити 480,000 пікселів -- 14,400,4000 обчислень на секунду! Саме так! Ця проблема настільки значуща, що може перевантажити мікропроцесор. Сучасний 2880х1800 Retina-дисплей оновлюваний 60 разів за секунду потребуватиме аж до 311,040,000 обчислень на секунду. Як же графічні інженери вирішують цю проблему!   

![](03.jpeg)

Ось де паралельні обчислення і стають у нагоді. Замість того, щоб тримати кілька великих і потужних процесорів (чи *труб*), розумніше мати купу маленьких мікропроцесорів працюючих паралельно одне з одним. Це й зроблено у графічному процесорі (GPU -- Graphical Processing Unit).

![Графічний процесор](04.jpeg)

Уявіть ці мікропроцесори у вигляді столу із труб, а данні кожного пікселя як м'ячики для настільного тенісу. 14,400,000 м'ячиків на секунду можуть заблокувати майже будь-яку трубу. Але стіл з 800х600 маленьких труб що отримують по 30 партій пікселів на секунду працюватимуть стабільно. Так само працює і для більших роздільних здібностей -- чим більше у вас обладнання здатного працювати паралельно, тим з більшим потоком воно справиться. 

Ще одною "супер-здібністю" графічних процесорів є апаратно-прискорені математичні функції, тож складні математичні операції роз'вязуються апаратно, а не програмно. Це дає надшвидкі тригонометричні і матричні операції, обмежені лише швидкістю світла.

## Що таке GLSL?

GLSL -- скорочення ві OpenGL Shading Language (мова шейдерів OpenGL), специфічний стандарт мови шейдерних програм розглянутих у наступних розділах. Існують і інші види шейдерів, залежно від апаратного забезпечення і операційних систем. Далі ми працюватимемо зі специфікацією OpenGL видавництва [Khronos Group](https://www.khronos.org/opengl/). Розуміння історії OpenGL може бути корисним і для розуміння більшості з дивакуватих домовленостей прийнятих в ній, для цього я рекомендую ознайомитися з [openglbook.com/chapter-0-preface-what-is-opengl.html (анг.)](http://openglbook.com/chapter-0-preface-what-is-opengl.html)

## Чим болючі шейдери?

"З великою силою приходить велика відповідальність" каже нам відомий афоризм. І для паралельних обчислень він також справджується. Потужність архітектури графічних процесорів тягне з собою також і деякі обмеження.

Для паралельної роботи кожен потік має бути незалежним від будь-якого іншого. Можна сказати, що вони "сліпі" до того чим зайняті інші. З цього обмеження витікає, що всі данні мають рухатися в одному напрямку, тож перевірка результату іншого потоку, змінення вхідних даних чи передача результатів роботи одного потоку в інший стають неможливими. Можливість взаємодії потоків була б ризиковою до цілісності даних.

Крім того, графічний процесор постійно навантажує паралельні мікропроцесори("труби") різною роботою надсилаючи нову інформацію для обробки щойно вони звільняться. Потік не може знати чим він займався минулого разу -- він міг малювати кнопку в графічному інтерфейсі операційної системи, потім відмальовути шматочок неба у грі, а потім відображав текст повідомлення електронної пошти. Кожен потік не лише **сліпий**, але й **не має пам'яті**. Необхідність рівня абстрагування для програмування загальної функції що змінює значення залежно від позиції пікселю разом зі сліпотою і забудькуватістю шейдерів не роблять їх популярними серед програмістів-початківців.  

Але не переживайте! В наступних розділах ми покроково пройдемо від простих до розширених шейдерних обчислень. Читаючи цей текст з сучасного браузеру ви зможете оцінити можливість погратися з інтерактивними прикладами. Тож не будемо більше зволікати, тисніть *Next >>* щоб поринути у код!
